{% set fname = "{{bench_location}}/{{name}}/tb/testbench/hdl_top.sv" %}
{% extends "base_template.TMPL" %}

{% block description %}
//----------------------------------------------------------------------                     
//               
// Description: This top level module instantiates all synthesizable
//    static content.  This and tb_top.sv are the two top level modules
//    of the simulation.  
//
//    This module instantiates the following:
//        DUT: The Design Under Test
//        Interfaces:  Signal bundles that contain signals connected to DUT
//        Driver BFM's: BFM's that actively drive interface signals
//        Monitor BFM's: BFM's that passively monitor interface signals
//
//----------------------------------------------------------------------

{% endblock %}

{% block contents %}

module hdl_top;

import {{name}}_parameters_pkg::*;
{% for agent in qvip_bfm_pkgs %}
import {{agent}}_params_pkg::*;
{% endfor %}
import uvmf_base_pkg_hdl::*;

{% if veloceReady %}
  // pragma attribute hdl_top partition_module_xrtl                                            
{% endif %}
{% for qvip_hdl in qvip_hdl_modules %}
  hdl_{{qvip_hdl.envPkg}} 
      #(
{% for agent_name in qvip_hdl.agent_names %}
        .{{agent_name}}_ACTIVE({% if qvip_hdl.agent_activities[agent_name]=='ACTIVE' %}1{% else %}0{% endif %}),
{% endfor %}
        .UNIQUE_ID("{{qvip_hdl.unique_id}}")
        /*.EXT_CLK_RESET(0)*/ 
       ) {{qvip_hdl.unique_id_with_underscores}}qvip_hdl();

{% endfor %}
{% if useCoEmuClkRstGen %}
  wire rst;
  wire clk;
  clock_bfm #(INIT_CLOCK_HALF_PERIOD) clk_if_h(clk);
  sync_reset_bfm #(RST_POLARITY,
                   INITIAL_IDLE_CYCLES,
                   RESET_ACTIVE_CYCLES) rst_if_h(clk, rst);
{% else %}
// pragma uvmf custom clock_generator begin
  bit clk;
  // Instantiate a clk driver 
{% if veloceReady %}
  // tbx clkgen
{% endif %}
  initial begin
    clk = 0;
    #{{ clockPhaseOffset }};
    forever begin
      clk = ~clk;
      #{{ clockHalfPeriod }};
    end
  end
// pragma uvmf custom clock_generator end

// pragma uvmf custom reset_generator begin
  bit rst;
  // Instantiate a rst driver
{% if veloceReady %}
  // tbx clkgen
{% endif %}
  initial begin
    rst = {% if resetAssertionLevel %}1{% else %}0{% endif %}; 
    #{{ resetDuration }};
    rst =  {% if resetAssertionLevel %}0{% else %}1{% endif %}; 
  end
// pragma uvmf custom reset_generator end
{% endif %}

  // pragma uvmf custom module_item_additional begin
  // pragma uvmf custom module_item_additional end

  // Instantiate the signal bundle, monitor bfm and driver bfm for each interface.
  // The signal bundle, _if, contains signals to be connected to the DUT.
  // The monitor, monitor_bfm, observes the bus, _if, and captures transactions.
  // The driver, driver_bfm, drives transactions onto the bus, _if.
  // A generate statement is used to produce hierarchy used in the %m registration 
  // with the config_db
  import uvm_pkg::uvm_config_db;
{% if BFMGenvars|length > 0 %}  genvar {% for var in BFMGenvars %}{{var}}{{macro.commalist(loop,",",";")}}{% endfor %}
{% endif %}

  generate
{% for inst in BFMInstructions %}
{% filter indent(width=2*inst["indent"]) %}
{% if inst["cmd"] == "start_block" %}

    // Starting new block representing HVL path {{inst["topo"].path()}}
    begin : {{inst["topo"].name}}

{% elif inst["cmd"] == "start_loop" or inst["cmd"] == "start_inst_loop" %}

    // Starting new loop representing arrayed HVL path {{inst["topo"].path()}}
    for ({{inst["genvar"]}}=0;{{inst["genvar"]}}<{{inst["topo"].instance_array_size}};{{inst["genvar"]}}++) begin : {{inst["topo"].name}}

{% elif inst["cmd"] == "instance_bfm" %}

     // Instantiating BFM structures for interface {{inst["topo"].path()}}
    {{inst["bfm_info"].bfm_type}}_if {{macro.paramUseNested(inst["param_info"])|indent(8)}} {{inst["bfm_info"].bfm_name}}_bus (
      // pragma uvmf custom {{inst["bfm_info"].bfm_name}}_bus_connections begin
      .{{inst["agent"].clock}}(clk), .{{inst["agent"].reset}}(rst)
      // pragma uvmf custom {{inst["bfm_info"].bfm_name}}_bus_connections end
    );
    {{inst["bfm_info"].bfm_type}}_monitor_bfm_top {{macro.paramUseNested(inst["param_info"])|indent(8)}} {{inst["bfm_info"].bfm_name}}_mon_bfm ({{inst["bfm_info"].bfm_name}}_bus.monitor_port);
    initial uvm_config_db #( virtual {{inst["bfm_info"].bfm_type}}_monitor_bfm {{macro.paramUseNested(inst["param_info"])|indent(8)}} )::set( null , UVMF_VIRTUAL_INTERFACES , $sformatf("%m.{{inst["bfm_info"].bfm_name}}") , {{inst["bfm_info"].bfm_name}}_mon_bfm.core ); 
{% if inst["bfm_info"].active_passive == 'ACTIVE' %}
    {{inst["bfm_info"].bfm_type}}_driver_bfm_top{{macro.paramUseNested(inst["param_info"])|indent(8)}} {{inst["bfm_info"].bfm_name}}_drv_bfm ({{inst["bfm_info"].bfm_name}}_bus.initiator_port);
    initial uvm_config_db #( virtual {{inst["bfm_info"].bfm_type}}_driver_bfm {{macro.paramUseNested(inst["param_info"])|indent(8)}} )::set( null , UVMF_VIRTUAL_INTERFACES , $sformatf("%m.{{inst["bfm_info"].bfm_name}}") , {{inst["bfm_info"].bfm_name}}_drv_bfm.core  );
{% endif %}
{% elif inst["cmd"] == "end" or inst["cmd"] == "end_block" or inst["cmd"] == "end_loop" or inst["cmd"] == "end_inst_loop" %}

      // Ending block representing path {{inst["topo"].path()}}
    end

{% endif %}
{% endfilter %}
{% endfor %}
  endgenerate

  // pragma uvmf custom dut_instantiation begin
  // UVMF_CHANGE_ME : Add DUT and connect to signals in _bus interfaces listed above
  // Instantiate your DUT here
  // pragma uvmf custom dut_instantiation end
{% if useCoEmuClkRstGen %}
  initial begin    // tbx vif_binding_block 
    import uvm_pkg::uvm_config_db;
    uvm_config_db #(virtual clock_bfm #(INIT_CLOCK_HALF_PERIOD))::set(null, UVMF_VIRTUAL_INTERFACES, CLOCK_CONTROLLER, clk_if_h);
    uvm_config_db #(virtual sync_reset_bfm #(RST_POLARITY, INITIAL_IDLE_CYCLES, RESET_ACTIVE_CYCLES))::set(null, UVMF_VIRTUAL_INTERFACES, RESET_CONTROLLER, rst_if_h);
  end
{% endif %}
endmodule

// pragma uvmf custom external begin
// pragma uvmf custom external end

{% endblock %}
