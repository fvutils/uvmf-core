{% set fname = "{{vip_location}}/{{interface_location}}/{{name}}_pkg/{{src_dir}}{{name}}_configuration.svh" %}
{% extends "base_template.TMPL" %}

{% block description %}
//----------------------------------------------------------------------
//                                          
// DESCRIPTION: This class contains all variables and functions used
//      to configure the {{name}} agent and its bfm's.  It gets the
//      bfm's from the uvm_config_db for use by the agent.
//
//----------------------------------------------------------------------
{% endblock %}

{% block contents %}
class {{name}}_configuration extends uvmf_deparameterized_agent_configuration_base #(
  .PARAMETER_BRIDGE_T({{name}}_param_bridge));

  `uvm_object_utils({{name}}_configuration)

{% for config in configVars %}
{% if config.comment|length > 0 %}  // {{config.comment}}
{% endif %}
  {% if config.isrand %}rand {% endif %}{{config.type}} {{config.name}}{% if config.unpackedDim != '' %} {{config.unpackedDim}}{% endif %}{% if config.value != '' %} = {{config.value}}{% endif %};
{% endfor %}

  // Sequencer handle populated by agent
  uvm_sequencer #({{name}}_transaction) sequencer;

  //Constraints for the configuration variables:
{% for cnstr in configVarsConstraints %}
{% if cnstr.comment|length > 0 %}  // {{cnstr.comment}}
{% endif %}
  constraint {{cnstr.name}} {{cnstr.type}}
{% endfor %}

  // pragma uvmf custom class_item_additional begin
  // pragma uvmf custom class_item_additional end
  
  covergroup {{name}}_configuration_cg;
    // pragma uvmf custom covergroup begin
    option.auto_bin_max=1024;
{% for config in configVars %}
{% if config.unpackedDim != '' %}//{% endif %}    coverpoint {{config.name}};
{% endfor %}
    // pragma uvmf custom covergroup end
  endgroup

{% if veloceReady %}
  //*******************************************************************
  //*******************************************************************
  // Structure used to pass configuration variables to monitor and driver BFM's.
  // Use to_struct function to pack variables into structure.
  // Use from_struct function to unpack variables from structure.
  // This structure is defined in {{name}}_macros.svh
  `{{name}}_CONFIGURATION_STRUCT
  {{name}}_configuration_s {{name}}_configuration_struct;
  //*******************************************************************
  // FUNCTION: to_struct()
  // This function packs variables into a {{name}}_configuration_s
  // structure.  The function returns the handle to the {{name}}_configuration_struct.
  // This function is defined in {{name}}_macros.svh
  `{{name}}_CONFIGURATION_TO_STRUCT_FUNCTION
  //*******************************************************************
  // FUNCTION: from_struct()
  // This function unpacks the struct provided as an argument into 
  // variables of this class.
  // This function is defined in {{name}}_macros.svh
  `{{name}}_CONFIGURATION_FROM_STRUCT_FUNCTION
{% endif %}

  // ****************************************************************************
  // FUNCTION : new()
  // This function is the standard SystemVerilog constructor.
  //
  function new( string name = "" );
    super.new( name );
    // Construct the covergroup for this configuration class 
    {{name}}_configuration_cg = new;
  endfunction

  // ****************************************************************************
  // FUNCTION: post_randomize()
  // This function is automatically called after the randomize() function 
  // is executed.
  //
  function void post_randomize();
    super.post_randomize();
    {{name}}_configuration_cg.sample();
  endfunction

  // ****************************************************************************
  // FUNCTION: initialize
  //                   This function causes the configuration to retrieve
  //                   its virtual interface handle from the uvm_config_db.
  //                   This function also makes itself available to its
  //                   agent through the uvm_config_db.
  //
  //                ARGUMENTS:
  //                   uvmf_active_passive_t activity:
  //                        This argument identifies the simulation level
  //                        as either BLOCK, CHIP, SIMULATION, etc.
  //
  //                   AGENT_PATH:
  //                        This argument identifies the path to this
  //                        configurations agent.  This configuration
  //                        makes itself available to the agent specified
  //                        by agent_path by placing itself into the
  //                        uvm_config_db.
  //
  //                   INTERFACE_NAME:
  //                        This argument identifies the string name of
  //                        this configurations BFM's.  This string
  //                        name is used to retrieve the driver and 
  //                        monitor BFM from the uvm_config_db.
  //
  virtual function void initialize(uvmf_active_passive_t activity,
                                            string agent_path,
                                            string interface_name);

    super.initialize( activity, agent_path, interface_name);
{% if enableFunctionalCoverage %}    has_coverage = 1;
{% endif %}
    // The covergroup is given the same name as the interface
    {{name}}_configuration_cg.set_inst_name(interface_name);

    // This configuration places itself into the uvm_config_db for the agent, identified by the agent_path variable, to retrieve.  
    uvm_config_db #( {{name}}_configuration)::set(null, agent_path, UVMF_AGENT_CONFIG, this);

    // This configuration also places itself in the config db using the same identifier used by the interface.  This allows users to access
    // configuration variables and the interface through the bfm api class rather than directly accessing the BFM.  This is useful for 
    // accessingthe BFM when using Veloce
    uvm_config_db #( {{name}}_configuration)::set(null, UVMF_CONFIGURATIONS, interface_name, this);

    {{name}}_configuration_cg.set_inst_name($sformatf("{{name}}_configuration_cg_%s",get_full_name()));

    // pragma uvmf custom initialize begin
    // This controls whether or not the agent returns a transaction handle in the driver when calling 
    // item_done() back into the sequencer or not. If set to 1, a transaction is sent back which means
    // the sequence on the other end must use the get_response() part of the driver/sequence API. If 
    // this doesn't occur, there will eventually be response_queue overflow errors during the test.
    return_transaction_response = 1'b0;

    // pragma uvmf custom initialize end

  endfunction

  // ****************************************************************************
  // FUNCTION: setup
  //       This function causes the configuration to retrieve its virtual 
  //       interface handle from the uvm_config_db.  This function also makes 
  //       itself available to its agent through the uvm_config_db.  It also 
  //       provides a location for protocol wide configuration settings.
  //
  //                ARGUMENTS:
  //
  //                   hdl_path:
  //                        This argument identifies the hierarchical path 
  //                        of BFM's associated with this agent. 
  //                        This configuration makes itself 
  //                        available to the agent specified
  //                        by agent_path by placing itself into the
  //                        uvm_config_db.
  //
  //
  virtual function void setup(string hdl_path);

    super.setup( hdl_path );

{% if enableFunctionalCoverage %}    has_coverage = 1; {% endif %}

    // The covergroup is given the same name as the interface
    {{name}}_configuration_cg.set_inst_name(hdl_path);

    // This configuration places itself into the uvm_config_db for the agent, identified by the agent_path variable, to retrieve.  
    uvm_config_db #( {{name}}_configuration)::set(null, hdl_path, UVMF_AGENT_CONFIG, this );

    // This configuration also places itself in the config db using the same identifier used by the interface.  This allows users to access
    // configuration variables and the interface through the bfm api class rather than directly accessing the BFM.  This is useful for 
    // accessingthe BFM when using Veloce
    uvm_config_db #( {{name}}_configuration)::set(null, UVMF_CONFIGURATIONS, hdl_path, this );

    {{name}}_configuration_cg.set_inst_name($sformatf("{{name}}_configuration_cg_%s",hdl_path));

    // pragma uvmf custom setup begin
    // This controls whether or not the agent returns a transaction handle in the driver when calling 
    // item_done() back into the sequencer or not. If set to 1, a transaction is sent back which means
    // the sequence on the other end must use the get_response() part of the driver/sequence API. If 
    // this doesn't occur, there will eventually be response_queue overflow errors during the test.
    return_transaction_response = 1'b0;

    // pragma uvmf custom setup end

  endfunction

  // ****************************************************************************
  // FUNCTION : convert2string()
  // This function is used to convert variables in this class into a string for log messaging.
  // 
  virtual function string convert2string ();
    // pragma uvmf custom convert2string begin
    return $sformatf("{% for config in configVars %}{{config.name}}:{%if config.unpackedDim != "" %}%p {% else %}0x%x {% endif %} {% endfor %}"{% for config in configVars %},{{config.name}}{% endfor %});
    // pragma uvmf custom convert2string end
  endfunction

  // ****************************************************************************
  // FUNCTION: get_sequencer
  function uvm_sequencer #({{name}}_transaction) get_sequencer();
    return sequencer;
  endfunction

endclass

// pragma uvmf custom external begin
// pragma uvmf custom external end

{% endblock %}
